def platforms = ['linux32', 'linux64', 'win32', 'win64', 'mac32', 'mac64']

// dependency configuration setup:
// configuration "compile_base" contains all platform-independent compile-time dependencies.
// configuration "compile_<platform>" contains all compile-time dependencies for platform <platform>.
// configuration "compile" contains all compile-time dependencies for the platform we're running on.
// configuration "runtime_<platform>" contains all runtime dependencies for platform <platform>.
// configuration "runtime" contains all runtime dependencies for the platform we're running on.

configurations.add 'compile_base'

dependencies {
    compile_base project(':viskit')
    compile_base "rhino:js:1.7R2"
    compile_base "org.hsqldb:hsqldb:2.0.0"
    compile_base "org.springframework:spring-core:$useSpringVersion"
    compile_base "org.springframework:spring-beans:$useSpringVersion"
    compile_base "org.springframework:spring-expression:$useSpringVersion"
    compile_base "org.springframework:spring-context:$useSpringVersion"
    compile_base "org.springframework:spring-aop:$useSpringVersion"
    compile_base "org.springframework:spring-aspects:$useSpringVersion"
    compile_base "org.springframework:spring-tx:$useSpringVersion"
    compile_base "org.springframework:spring-jdbc:$useSpringVersion"
    compile_base "log4j:log4j:1.2.13"
    compile_base "commons-lang:commons-lang:2.5"
    compile_base "com.google.guava:guava:r05"
    compile_base "net.java.dev.appframework:appframework:1.03"
    compile_base "org.swinglabs:swing-layout:1.0.3"
    compile_base "net.java.dev.beansbinding:beansbinding:1.2.1"
    compile_base "dcm4che:dcm4che-core:2.0.24"
    compile_base "dcm4che:dcm4che-imageio:2.0.24"
}

platforms.each { p ->
    def platform_compile_config = configurations.add "compile_$p"
    dependencies.add "compile_$p", "net.sf.qtjambi:qtjambi-base-$p:4.6.3.2"
    platform_compile_config.extendsFrom configurations.compile_base

    def platform_runtime_config = configurations.add "runtime_$p"
    dependencies.add "runtime_$p", "net.sf.qtjambi:qtjambi-platform-$p:4.6.3.2"
    platform_runtime_config.extendsFrom platform_compile_config
}

def runningPlatform = getRunningPlatform()
if (runningPlatform) {
    configurations.compile.extendsFrom configurations["compile_$runningPlatform"]
    configurations.runtime.extendsFrom configurations["runtime_$runningPlatform"]
}

def getRunningPlatform() {
    def oses = [linux:'linux', windows:'win', mac:'mac']
    def archs = [x86:'32', i386:'32', amd64:'64', x86_64:'64', x64:'64']
    def osname = System.getProperty("os.name").split()[0].toLowerCase()
    def osarch = System.getProperty("os.arch")
    def os = oses[osname]
    def arch = archs[osarch]
    if (!os || !arch) {
        //unsupported platform (but we can still compile here)
        return null;
    }
    return "$os$arch"
}


def mainClassName = 'de.sofd.iirkit.App'

task run(type: JavaExec) {
    description = 'Run iirkit directly from the build directory'
    classpath = sourceSets.main.runtimeClasspath
    main = mainClassName
    //args = //TODO
}

platforms.each { p ->
    ssTask = project.tasks.add("startScripts_$p", org.gradle.api.tasks.application.CreateStartScripts)
    ssTask.description = "Creates start scripts ($p)"
    ssTask.mainClassName = mainClassName
    ssTask.applicationName = 'iirkit'
    ssTask.classpath = tasks[JavaPlugin.JAR_TASK_NAME].outputs.files + configurations["runtime_$p"]
    ssTask.outputDir = new File(project.buildDir, "scripts_$p")

    def applicationDistribution = project.copySpec {
        from(project.file("src/dist"))
        
        into("lib") {
            from(tasks[JavaPlugin.JAR_TASK_NAME])
            from(configurations["runtime_$p"])
        }
        into("bin") {
            from(ssTask)
            fileMode = 0755
        }
    }

    def instTask = tasks.add("install_$p", org.gradle.api.tasks.Sync)
    instTask.description = "Installs the project, including all dependencies, into a directory, for creating the zip file later ($p)"
    instTask.with applicationDistribution
    instTask.into { project.file("${project.buildDir}/install_${p}/iirkit") }
    instTask.doFirst {
        if (destinationDir.directory) {
            if (!new File(destinationDir, 'lib').directory || !new File(destinationDir, 'bin').directory) {
                throw new GradleException("The specified installation directory '${destinationDir}' is neither empty nor does it contain an installation for iirkit.\n" +
                                          "If you really want to install to this directory, delete it and run the install task again.\n" +
                                          "Alternatively, choose a different installation directory."
                                         )
            }
        }
    }
    instTask.doLast {
        project.ant.chmod(file: "${destinationDir.absolutePath}/bin/iirkit", perm: 'ugo+x')
    }

    def distZipTask = project.tasks.add("distZip_$p", org.gradle.api.tasks.bundling.Zip)
    distZipTask.description = "Bundles the project as a JVM application with libs and OS specific scripts into a zip file ($p)"
    distZipTask.baseName = "iirkit-$p"
    def baseDir = { distZipTask.archiveName - ".zip" }
    distZipTask.into(baseDir) {
        with(applicationDistribution)
    }
}

if (runningPlatform) {
    task distZip {
        description "Bundles the project as a JVM application with libs and OS specific scripts into a zip file for the running platform ($runningPlatform)"
        dependsOn tasks["distZip_$runningPlatform"]
    }
}

task distZipAll {
    description "Creates zip files for all supported platforms"
    platforms.each { p ->
        dependsOn tasks["distZip_$p"]
    }
}
